/**
 * Created by Sergej on 05.09.2016.
 */
const SYMBOL_OR = '∨';
const SYMBOL_AND = '∧';
const SYMBOL_NEG = '¬';

const DN_NR = ['₀','₁','₂','₃','₄','₅','₆','₇','₈','₉'];
const UP_NR = ['⁰','¹','²','³','⁴','⁵','⁶','⁷','⁸','⁹'];

const KEY_LEFT      = 37;
const KEY_RIGHT     = 39;
const KEY_UP        = 38;
const KEY_DOWN      = 40;
const KEY_BACKSPACE = 8;

const KEY_A = 65;
const KEY_Z = 90;
const KEY_NUM_0 = 96;
const KEY_NUM_1 = 97;
const KEY_0 = 48;
const KEY_1 = 49;
const KEY_2 = 50;
const KEY_3 = 51;
const KEY_4 = 52;
const KEY_5 = 53;
const KEY_6 = 54;
const KEY_7 = 55;
const KEY_8 = 56;
const KEY_9 = 57;

const KEY_DOT   = 190;
const KEY_COMMA = 188;
/**
 * Created by Sergej on 06.09.2016.
 */
DomUtils = {
    getCaretPosition: function (editableDiv) {
        var caretPos = 0,
            sel, range;
        if (window.getSelection) {
            sel = window.getSelection();
            if (sel.rangeCount) {
                range = sel.getRangeAt(0);
                if (range.commonAncestorContainer.parentNode == editableDiv) {
                    caretPos = range.endOffset;
                }
            }
        } else if (document.selection && document.selection.createRange) {
            range = document.selection.createRange();
            if (range.parentElement() == editableDiv) {
                var tempEl = document.createElement("span");
                editableDiv.insertBefore(tempEl, editableDiv.firstChild);
                var tempRange = range.duplicate();
                tempRange.moveToElementText(tempEl);
                tempRange.setEndPoint("EndToEnd", range);
                caretPos = tempRange.text.length;
            }
        }
        return caretPos;
    },
    insertTextAtCursor: function (text) {
        var sel, range, html;
        if (window.getSelection) {
            sel = window.getSelection();
            if (sel.getRangeAt && sel.rangeCount) {
                range = sel.getRangeAt(0);
                range.deleteContents();
                range.insertNode(document.createTextNode(text));
                range.endOffset++;
            }
        } else if (document.selection && document.selection.createRange) {
            document.selection.createRange().text = text;
        }
    },
    pasteHtmlAtCaret: function (html, node) {
        var sel, range;
        if (window.getSelection) {
            // IE9 and non-IE
            sel = window.getSelection();
            if (sel.getRangeAt && sel.rangeCount) {
                range = sel.getRangeAt(0);
                if (node && (range.startContainer.id != node.id || range.endContainer.id != node.id || range.startContainer.className != node.className || range.endContainer.className != node.className)) {
                    console.log(node);
                    console.log(range);
                    return false;
                }
                range.deleteContents();

                // Range.createContextualFragment() would be useful here but is
                // non-standard and not supported in all browsers (IE9, for one)
                var el = document.createElement("div");
                el.innerHTML = html;
                var frag = document.createDocumentFragment(), node, lastNode;
                while ((node = el.firstChild)) {
                    lastNode = frag.appendChild(node);
                }
                if (lastNode == node) return;
                range.insertNode(frag);

                // Preserve the selection
                if (lastNode) {
                    range = range.cloneRange();
                    range.setStartAfter(lastNode);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            }
        } else if (document.selection && document.selection.type != "Control") {
            // IE < 9
            document.selection.createRange().pasteHTML(html);
        }
    },
    saveSelection: function () {
        if (window.getSelection) {
            var sel = window.getSelection();
            if (sel.getRangeAt && sel.rangeCount) {
                return sel.getRangeAt(0);
            }
        } else if (document.selection && document.selection.createRange) {
            return document.selection.createRange();
        }
        return null;
    },
    restoreSelection: function (range) {
        if (range) {
            if (window.getSelection) {
                var sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            } else if (document.selection && range.select) {
                range.select();
            }
        }
    },
    getSelectionStart: function() {
        var node = document.getSelection().getStartElement();
        console.log(node.nodeType);
        return node;
    },
    getCaretCharacterOffsetWithin: function(element) {
        var caretOffset = 0;
        var doc = element.ownerDocument || element.document;
        var win = doc.defaultView || doc.parentWindow;
        var sel;
        if (typeof win.getSelection != "undefined") {
            sel = win.getSelection();
            if (sel.rangeCount > 0) {
                var range = win.getSelection().getRangeAt(0);
                var preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(element);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                caretOffset = preCaretRange.toString().length;
            }
        } else if ((sel = doc.selection) && sel.type != "Control") {
            var textRange = sel.createRange();
            var preCaretTextRange = doc.body.createTextRange();
            preCaretTextRange.moveToElementText(element);
            preCaretTextRange.setEndPoint("EndToEnd", textRange);
            caretOffset = preCaretTextRange.text.length;
        }
        return caretOffset;
    },

    setCaretPosition: function(element, offset) {
        var range = document.createRange();
        var sel = window.getSelection();

        //select appropriate node
        var currentNode = null;
        var previousNode = null;

        for (var i = 0; i < element.childNodes.length; i++) {
            //save previous node
            previousNode = currentNode;

            //get current node
            currentNode = element.childNodes[i];
            //if we get span or something else then we should get child node
            while(currentNode.childNodes.length > 0){
                currentNode = currentNode.childNodes[0];
            }

            //calc offset in current node
            if (previousNode != null) {
                offset -= previousNode.length;
            }
            //check whether current node has enough length
            if (offset <= currentNode.length) {
                break;
            }
        }
        //move caret to specified offset
        if (currentNode != null) {
            if (currentNode.length < offset) {
                offset--;
            }
            range.setStart(currentNode, offset);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
        }
    },
    getSelectedText: function(withHtml) {
        var html = "";
        if (typeof window.getSelection != "undefined") {
            var sel = window.getSelection();
            if (sel.rangeCount) {
                var container = document.createElement("div");
                for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                    container.appendChild(sel.getRangeAt(i).cloneContents());
                }
                if (withHtml) {
                    html = container.innerHTML;
                }
                else {
                    html = container.innerText;
                }
            }
        } else if (typeof document.selection != "undefined") {
            if (document.selection.type == "Text") {
                if (withHtml) {
                    html = document.selection.createRange().htmlText;
                } else {
                    html = document.selection.createRange().text;
                }
            }
        }
        return html;
    }
};
/**
 * Created by Sergej on 05.09.2016.
 */
var Formula = function(text) {
    var pattern = "(¬*([A-Za-z|1|0])(∧|∨)?)*";
    var patternExt = "(¬*([((A-Za-z)(1-9)*)|1|0])(∧|∨)?)*";

    var regex = new RegExp(patternExt);
    var match = text.match(regex);

    this.isValid = function(){
        if (text.length == 0) return true;
        var firstChar = text.charAt(0);
        var lastChar = text.charAt(text.length - 1);
        return lastChar != SYMBOL_AND && lastChar != SYMBOL_OR
            && firstChar != SYMBOL_AND && firstChar != SYMBOL_OR
            && match[0] != "" && match[0] == text;
    };

    this.getText = function(){
        return text;
    };
    this.getHtml = function(){
        var rtn = "";
        // Dummy - Später wird das aus dem Baum generiert
        var lastChar = '';
        for (var i = 0; i < text.length; i++) {
            var char = text.charAt(i);
            if (char == SYMBOL_AND || char == SYMBOL_NEG || char == SYMBOL_OR) {
                char = '<span class="op">'+char+'</span>';
            } else {
                if ((i+1) < text.length && char == 'G') {
                    var number = text.charAt(i+1);
                    var code = number.charCodeAt(0);
                    if (code >= KEY_0 && code <= KEY_9) {
                        number = '<sub>' + number + '</sub>';
                    }
                }
                char = '<span class="expr">' + char + '</span>';
            }
            rtn += char;
        }
        return rtn;
    };
};

function REX(text) {
    console.log( (new Formula(text)).isValid());
}
/**
 * Created by Sergej on 03.09.2016.
 */
var boolAlg = angular.module('boolean-algebra', [
    'ngRoute',
    'pascalprecht.translate'
]).config(function ($routeProvider, $locationProvider) {
    $routeProvider.when('/', {
        templateUrl: '/view/boolalg.html',
        controller: 'BACtrl'
    });
    $routeProvider.otherwise({
        redirectTo: '/'
    });
    $locationProvider.html5Mode(true);
}).config(['$translateProvider', function ($translateProvider) {
    //translation
    $translateProvider.useStaticFilesLoader({
        prefix: 'translations/lang-',
        suffix: '.json'
    });
    // Enable escaping of HTML
    $translateProvider.useSanitizeValueStrategy('escape');

    $translateProvider.preferredLanguage('de_DE');
}]);